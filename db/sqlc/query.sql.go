// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const CreateCharge = `-- name: CreateCharge :one
INSERT INTO charges (
    id, amount, currency, status, customer_id, payment_method_id, description, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, amount, currency, status, customer_id, payment_method_id, description, metadata, created_at, updated_at
`

type CreateChargeParams struct {
	ID              string                `json:"id"`
	Amount          int64                 `json:"amount"`
	Currency        string                `json:"currency"`
	Status          string                `json:"status"`
	CustomerID      string                `json:"customer_id"`
	PaymentMethodID sql.NullString        `json:"payment_method_id"`
	Description     sql.NullString        `json:"description"`
	Metadata        pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) CreateCharge(ctx context.Context, db DBTX, arg CreateChargeParams) (Charge, error) {
	row := db.QueryRowContext(ctx, CreateCharge,
		arg.ID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.CustomerID,
		arg.PaymentMethodID,
		arg.Description,
		arg.Metadata,
	)
	var i Charge
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.CustomerID,
		&i.PaymentMethodID,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
    id, email, name, phone, description, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, email, name, phone, description, metadata, created_at, updated_at
`

type CreateCustomerParams struct {
	ID          string                `json:"id"`
	Email       string                `json:"email"`
	Name        string                `json:"name"`
	Phone       sql.NullString        `json:"phone"`
	Description sql.NullString        `json:"description"`
	Metadata    pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) CreateCustomer(ctx context.Context, db DBTX, arg CreateCustomerParams) (Customer, error) {
	row := db.QueryRowContext(ctx, CreateCustomer,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Phone,
		arg.Description,
		arg.Metadata,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Phone,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreatePaymentMethod = `-- name: CreatePaymentMethod :one
INSERT INTO payment_methods (
    id, type, customer_id, card_last4, card_brand, card_exp_month, card_exp_year, card_fingerprint, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, type, customer_id, card_last4, card_brand, card_exp_month, card_exp_year, card_fingerprint, metadata, created_at
`

type CreatePaymentMethodParams struct {
	ID              string                `json:"id"`
	Type            string                `json:"type"`
	CustomerID      string                `json:"customer_id"`
	CardLast4       sql.NullString        `json:"card_last4"`
	CardBrand       sql.NullString        `json:"card_brand"`
	CardExpMonth    sql.NullInt32         `json:"card_exp_month"`
	CardExpYear     sql.NullInt32         `json:"card_exp_year"`
	CardFingerprint sql.NullString        `json:"card_fingerprint"`
	Metadata        pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, db DBTX, arg CreatePaymentMethodParams) (PaymentMethod, error) {
	row := db.QueryRowContext(ctx, CreatePaymentMethod,
		arg.ID,
		arg.Type,
		arg.CustomerID,
		arg.CardLast4,
		arg.CardBrand,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.CardFingerprint,
		arg.Metadata,
	)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CustomerID,
		&i.CardLast4,
		&i.CardBrand,
		&i.CardExpMonth,
		&i.CardExpYear,
		&i.CardFingerprint,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const CreateRefund = `-- name: CreateRefund :one
INSERT INTO refunds (
    id, charge_id, amount, currency, status, reason, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, charge_id, amount, currency, status, reason, metadata, created_at, updated_at
`

type CreateRefundParams struct {
	ID       string                `json:"id"`
	ChargeID string                `json:"charge_id"`
	Amount   int64                 `json:"amount"`
	Currency string                `json:"currency"`
	Status   string                `json:"status"`
	Reason   sql.NullString        `json:"reason"`
	Metadata pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) CreateRefund(ctx context.Context, db DBTX, arg CreateRefundParams) (Refund, error) {
	row := db.QueryRowContext(ctx, CreateRefund,
		arg.ID,
		arg.ChargeID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.Reason,
		arg.Metadata,
	)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.ChargeID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.Reason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers
WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, DeleteCustomer, id)
	return err
}

const DeletePaymentMethod = `-- name: DeletePaymentMethod :exec
DELETE FROM payment_methods
WHERE id = $1 AND customer_id = $2
`

type DeletePaymentMethodParams struct {
	ID         string `json:"id"`
	CustomerID string `json:"customer_id"`
}

func (q *Queries) DeletePaymentMethod(ctx context.Context, db DBTX, arg DeletePaymentMethodParams) error {
	_, err := db.ExecContext(ctx, DeletePaymentMethod, arg.ID, arg.CustomerID)
	return err
}

const GetCharge = `-- name: GetCharge :one
SELECT id, amount, currency, status, customer_id, payment_method_id, description, metadata, created_at, updated_at FROM charges
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCharge(ctx context.Context, db DBTX, id string) (Charge, error) {
	row := db.QueryRowContext(ctx, GetCharge, id)
	var i Charge
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.CustomerID,
		&i.PaymentMethodID,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetChargeStats = `-- name: GetChargeStats :one
SELECT 
    COUNT(*) as total_charges,
    SUM(amount) as total_amount,
    COUNT(CASE WHEN status = 'succeeded' THEN 1 END) as successful_charges,
    SUM(CASE WHEN status = 'succeeded' THEN amount ELSE 0 END) as successful_amount
FROM charges
`

type GetChargeStatsRow struct {
	TotalCharges      int64 `json:"total_charges"`
	TotalAmount       int64 `json:"total_amount"`
	SuccessfulCharges int64 `json:"successful_charges"`
	SuccessfulAmount  int64 `json:"successful_amount"`
}

func (q *Queries) GetChargeStats(ctx context.Context, db DBTX) (GetChargeStatsRow, error) {
	row := db.QueryRowContext(ctx, GetChargeStats)
	var i GetChargeStatsRow
	err := row.Scan(
		&i.TotalCharges,
		&i.TotalAmount,
		&i.SuccessfulCharges,
		&i.SuccessfulAmount,
	)
	return i, err
}

const GetCustomer = `-- name: GetCustomer :one
SELECT id, email, name, phone, description, metadata, created_at, updated_at FROM customers
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCustomer(ctx context.Context, db DBTX, id string) (Customer, error) {
	row := db.QueryRowContext(ctx, GetCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Phone,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT id, email, name, phone, description, metadata, created_at, updated_at FROM customers
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetCustomerByEmail(ctx context.Context, db DBTX, email string) (Customer, error) {
	row := db.QueryRowContext(ctx, GetCustomerByEmail, email)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Phone,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCustomerStats = `-- name: GetCustomerStats :one
SELECT 
    COUNT(*) as total_customers,
    COUNT(CASE WHEN created_at >= NOW() - INTERVAL '30 days' THEN 1 END) as new_customers_30d,
    COUNT(CASE WHEN created_at >= NOW() - INTERVAL '7 days' THEN 1 END) as new_customers_7d
FROM customers
`

type GetCustomerStatsRow struct {
	TotalCustomers  int64 `json:"total_customers"`
	NewCustomers30d int64 `json:"new_customers_30d"`
	NewCustomers7d  int64 `json:"new_customers_7d"`
}

func (q *Queries) GetCustomerStats(ctx context.Context, db DBTX) (GetCustomerStatsRow, error) {
	row := db.QueryRowContext(ctx, GetCustomerStats)
	var i GetCustomerStatsRow
	err := row.Scan(&i.TotalCustomers, &i.NewCustomers30d, &i.NewCustomers7d)
	return i, err
}

const GetPaymentMethod = `-- name: GetPaymentMethod :one
SELECT id, type, customer_id, card_last4, card_brand, card_exp_month, card_exp_year, card_fingerprint, metadata, created_at FROM payment_methods
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPaymentMethod(ctx context.Context, db DBTX, id string) (PaymentMethod, error) {
	row := db.QueryRowContext(ctx, GetPaymentMethod, id)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CustomerID,
		&i.CardLast4,
		&i.CardBrand,
		&i.CardExpMonth,
		&i.CardExpYear,
		&i.CardFingerprint,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const GetRefund = `-- name: GetRefund :one
SELECT id, charge_id, amount, currency, status, reason, metadata, created_at, updated_at FROM refunds
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRefund(ctx context.Context, db DBTX, id string) (Refund, error) {
	row := db.QueryRowContext(ctx, GetRefund, id)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.ChargeID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.Reason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetRefundStats = `-- name: GetRefundStats :one
SELECT 
    COUNT(*) as total_refunds,
    SUM(amount) as total_amount,
    COUNT(CASE WHEN status = 'succeeded' THEN 1 END) as successful_refunds,
    SUM(CASE WHEN status = 'succeeded' THEN amount ELSE 0 END) as successful_amount
FROM refunds
`

type GetRefundStatsRow struct {
	TotalRefunds      int64 `json:"total_refunds"`
	TotalAmount       int64 `json:"total_amount"`
	SuccessfulRefunds int64 `json:"successful_refunds"`
	SuccessfulAmount  int64 `json:"successful_amount"`
}

func (q *Queries) GetRefundStats(ctx context.Context, db DBTX) (GetRefundStatsRow, error) {
	row := db.QueryRowContext(ctx, GetRefundStats)
	var i GetRefundStatsRow
	err := row.Scan(
		&i.TotalRefunds,
		&i.TotalAmount,
		&i.SuccessfulRefunds,
		&i.SuccessfulAmount,
	)
	return i, err
}

const ListAllCharges = `-- name: ListAllCharges :many
SELECT id, amount, currency, status, customer_id, payment_method_id, description, metadata, created_at, updated_at FROM charges
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllChargesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllCharges(ctx context.Context, db DBTX, arg ListAllChargesParams) ([]Charge, error) {
	rows, err := db.QueryContext(ctx, ListAllCharges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Charge{}
	for rows.Next() {
		var i Charge
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.CustomerID,
			&i.PaymentMethodID,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllRefunds = `-- name: ListAllRefunds :many
SELECT id, charge_id, amount, currency, status, reason, metadata, created_at, updated_at FROM refunds
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllRefundsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllRefunds(ctx context.Context, db DBTX, arg ListAllRefundsParams) ([]Refund, error) {
	rows, err := db.QueryContext(ctx, ListAllRefunds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Refund{}
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.ChargeID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.Reason,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCharges = `-- name: ListCharges :many
SELECT id, amount, currency, status, customer_id, payment_method_id, description, metadata, created_at, updated_at FROM charges
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListChargesParams struct {
	CustomerID string `json:"customer_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListCharges(ctx context.Context, db DBTX, arg ListChargesParams) ([]Charge, error) {
	rows, err := db.QueryContext(ctx, ListCharges, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Charge{}
	for rows.Next() {
		var i Charge
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.CustomerID,
			&i.PaymentMethodID,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCustomers = `-- name: ListCustomers :many
SELECT id, email, name, phone, description, metadata, created_at, updated_at FROM customers
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCustomersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCustomers(ctx context.Context, db DBTX, arg ListCustomersParams) ([]Customer, error) {
	rows, err := db.QueryContext(ctx, ListCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Phone,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPaymentMethods = `-- name: ListPaymentMethods :many
SELECT id, type, customer_id, card_last4, card_brand, card_exp_month, card_exp_year, card_fingerprint, metadata, created_at FROM payment_methods
WHERE customer_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentMethods(ctx context.Context, db DBTX, customerID string) ([]PaymentMethod, error) {
	rows, err := db.QueryContext(ctx, ListPaymentMethods, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentMethod{}
	for rows.Next() {
		var i PaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CustomerID,
			&i.CardLast4,
			&i.CardBrand,
			&i.CardExpMonth,
			&i.CardExpYear,
			&i.CardFingerprint,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRefunds = `-- name: ListRefunds :many
SELECT id, charge_id, amount, currency, status, reason, metadata, created_at, updated_at FROM refunds
WHERE charge_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRefundsParams struct {
	ChargeID string `json:"charge_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListRefunds(ctx context.Context, db DBTX, arg ListRefundsParams) ([]Refund, error) {
	rows, err := db.QueryContext(ctx, ListRefunds, arg.ChargeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Refund{}
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.ChargeID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.Reason,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateChargeStatus = `-- name: UpdateChargeStatus :one
UPDATE charges
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, amount, currency, status, customer_id, payment_method_id, description, metadata, created_at, updated_at
`

type UpdateChargeStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateChargeStatus(ctx context.Context, db DBTX, arg UpdateChargeStatusParams) (Charge, error) {
	row := db.QueryRowContext(ctx, UpdateChargeStatus, arg.ID, arg.Status)
	var i Charge
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.CustomerID,
		&i.PaymentMethodID,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET email = $2, name = $3, phone = $4, description = $5, metadata = $6, updated_at = NOW()
WHERE id = $1
RETURNING id, email, name, phone, description, metadata, created_at, updated_at
`

type UpdateCustomerParams struct {
	ID          string                `json:"id"`
	Email       string                `json:"email"`
	Name        string                `json:"name"`
	Phone       sql.NullString        `json:"phone"`
	Description sql.NullString        `json:"description"`
	Metadata    pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, db DBTX, arg UpdateCustomerParams) (Customer, error) {
	row := db.QueryRowContext(ctx, UpdateCustomer,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Phone,
		arg.Description,
		arg.Metadata,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Phone,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateRefundStatus = `-- name: UpdateRefundStatus :one
UPDATE refunds
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, charge_id, amount, currency, status, reason, metadata, created_at, updated_at
`

type UpdateRefundStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateRefundStatus(ctx context.Context, db DBTX, arg UpdateRefundStatusParams) (Refund, error) {
	row := db.QueryRowContext(ctx, UpdateRefundStatus, arg.ID, arg.Status)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.ChargeID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.Reason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
